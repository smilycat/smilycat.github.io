<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[猫舍]]></title>
  <subtitle><![CDATA[沉默的大多数喵]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blankpapers.com/"/>
  <updated>2015-09-20T02:07:58.000Z</updated>
  <id>http://blankpapers.com/</id>
  
  <author>
    <name><![CDATA[3mi1yc@t]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Mocks 不是 Stubs「译文」]]></title>
    <link href="http://blankpapers.com/2015/09/11/mocks-are-not-stubs/"/>
    <id>http://blankpapers.com/2015/09/11/mocks-are-not-stubs/</id>
    <published>2015-09-11T05:43:21.000Z</published>
    <updated>2015-09-20T02:07:58.000Z</updated>
    <content type="html"><![CDATA[<div style="text-align:center" markdown="1"><br><img src="/assets/img/mocks-and-stubs.png" alt="mock&amp;stub"><br></div>

<p>最近在项目上做了一些跟测试相关的工作，这才发现以前的一些理论并不扎实，在跟别人吹牛的时候也容易被人问住，就找了一些旧文好好研究一下，看完后顿觉恍然大悟。</p>
<p>为了让对测试有兴趣但英语不佳的同学能够快速理解这些测试方法，觉得应该好好翻译一下。在网上搜了一下译文，发现有哥们 dennis-xlc 已经翻译了部分，我接着他的部分继续翻完，希望能给对测试有兴趣的同学一些启示。</p>
<a id="more"></a>
<h3 id="dennis-xlc翻译部分"><strong>dennis-xlc翻译部分</strong></h3><p><em>译者注： 本文是<a href="http://martinfowler.com/" target="_blank" rel="external">Martin Fowler</a>大神的<a href="http://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="external">Mocks Aren’t Stubs</a>文章的中文翻译。由于该文是对mock对象和stub对象的探讨，故此译文中将不对mock和stub进行翻译，以避免混淆。</em></p>
<p>在测试领域中， ‘mock对象’已经成为一个流行术语，通常用来描述模拟真实对象的一类特殊对象。现在大部分语言都存在能够轻松地创建mock对象的框架。 但是， 通常人们都没有意识到，对于不同类型的测试中使用的特殊测试对象而言， mock对象仅仅是其中的一种而已。本文将会介绍mock对象是如何工作的、如何推进基于行为验证的测试以及社区是如何利用它来开发不同类型的测试。</p>
<p>我是几年前在XP(极限编程)社区中第一次接触到“mock对象”这个术语。之后我就越来越多地看到mock对象一词。一部分原因是很多mcok对象方面顶尖的开发者不时地成为我在ThoughtWorks的同事，还有部分原因是在受XP影响的测试讲座中我越来越多地看到mock对象的身影。</p>
<p>然而，大多数情况人们都没有恰当地理解mock对象。实际上我经常看到人们将mock对象和stubs这个常用于测试的公共类混淆起来。 我可以理解这种困惑，因为之前有段时间我也将两者视为类似的东西，但之后与mock开发者的交流中我终于茅塞顿开，对mock有了更深的理解。</p>
<p>两者其实存在两大区别。 首先，在如何验证结果方面，两者存在差异： 一个是状态的验证，一个是行为的验证。 其次，在测试和设计相结合的理念上两者大相径庭。 我将这种两者分别称作测试驱动开发的传统风格和mock风格(mockist)。</p>
<p>(在本文的早些版本里，我已意识到这两者之间存在区别，但我将这两个区别合二为一了。从那之后我对此的理解逐渐加深，所以现在是时候更新本文。如果你没有看过之前的版本，那么请忽略我这成长的苦恼。我是假设不存在旧版本的前提下写本文的。但如果你对旧版本有所了解，你会发现旧版本中我将两者的不同分为基于状态的测试和基于交互的测试，而本文中我将不同点改为状态的验证和行为的验证。同时，我也借鉴Gerard Meszaros的<a href="http://xunitpatterns.com/" target="_blank" rel="external">xUnit模式</a>一书的术语来调整我的措辞。)</p>
<h3 id="常规测试（Regular_Tests）">常规测试（Regular Tests）</h3><p>我将通过一个简单的例子来阐述这两种不同的风格。(该例子用Java实现，但其中原理适用于任何面向对象的语言。)我们有一个订单对象，还有一个仓库对象来处理该订单对象。该订单非常简单，只有一个产品和一个数量。仓库则保存着不同产品的库存量。当我们使用一个仓库对象来处理一个订单对象时可能会有两种结果。假如仓库拥有足够的产品来处理该订单，该订单状态变成已处理，同时仓库中产品的数量减掉该订单中的数量。如果仓库没有足够的产品，则改订单状态变为未处理，仓库状态保持不变。</p>
<p>这两种行为对应一系列测试，这些测试看起来很像常见的JUnit测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStateTester</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String TALISKER = <span class="string">"Talisker"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String HIGHLAND_PARK = <span class="string">"Highland Park"</span>;</span><br><span class="line">  <span class="keyword">private</span> Warehouse warehouse = <span class="keyword">new</span> WarehouseImpl();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    warehouse.add(TALISKER, <span class="number">50</span>);</span><br><span class="line">    warehouse.add(HIGHLAND_PARK, <span class="number">25</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrderIsFilledIfEnoughInWarehouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">50</span>);</span><br><span class="line">    order.fill(warehouse);</span><br><span class="line">    assertTrue(order.isFilled());</span><br><span class="line">    assertEquals(<span class="number">0</span>, warehouse.getInventory(TALISKER));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrderDoesNotRemoveIfNotEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">51</span>);</span><br><span class="line">    order.fill(warehouse);</span><br><span class="line">    assertFalse(order.isFilled());</span><br><span class="line">    assertEquals(<span class="number">50</span>, warehouse.getInventory(TALISKER));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>xUnit测试遵循典型的4个阶段：启动(setup)，执行(exercise)，验证(verify)，关闭(teardown)。在这个例子中，启动阶段有一部分是在<code>setUp</code>方法完成的(初始化仓库)，还有一部分是在测试方法里完成的(初始化订单)。<strong>order.fill</strong>方法会在执行阶段中调用。执行阶段中测试对象以我们想要测试的方式来执行。断言语句就是验证阶段，主要检查执行阶段中的方法是否正确地完成了任务。在这个例子中没有显式的关闭阶段，因为垃圾回收器会隐式地做清理。</p>
<p>在启动阶段中我们将两类对象放到了一起。<code>Order</code>类是我们要测试的类，但<strong>Order.fill</strong>方法执行的时候还需要一个<code>Warehouse</code>的实例。这种情况下我们关注点是<code>Order</code>类。面向测试的人喜欢称这类事物为<code>测试对象</code>(object-under-test)或<code>测试系统</code>(system-under-test)。这两个词都相当拗口，但由于这些术语已经深入人心，我也只好勉为其难地使用它们。参照Meszaros我将用<code>测试系统</code>(System Under Test)一词，或者它的缩写<code>SUT</code>。</p>
<p>在这个测试中我需要SUT(<strong>订单Order</strong>)和一个协作者(<strong>仓库</strong>)。需要用到仓库是基于以下两个原因：一是让测试可以正常执行(因为<strong>Order.fill</strong>方法要调用仓库的方法)，二是需要它来进行验证(因为Order.fill方法会改变仓库的状态)。随着对该话题的深入探讨，你将发现我们会严格区分SUT和协作者这两个概念。(在本文的早期版本中我称SUT为<code>“首要对象”</code>(primary object)，协作者成为<code>“辅助对象”</code>(secondary objects))。</p>
<p>这种风格的测试使用的是<strong>状态验证</strong>：也就是在执行步骤结束后通过检查SUT和协作者的状态来判定执行阶段中的方法是否正常工作。接下来我们会看到mock对象是以另外一种方式来进行验证的。</p>
<h3 id="基于mock对象的测试_(Tests_with_Mock_Objects)">基于mock对象的测试 (Tests with Mock Objects)</h3><p>接下来我会用mock对象来实现相同的行为。下面的代码会使用jMock类库来创建mock对象。jMock是一个Java实现的mock对象类库。除此之外还有其他的类库，但jMock是由mock技术创始人所写的较新的类库，因此采用它作为开始是个不错的选择。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderInteractionTester</span> <span class="keyword">extends</span> <span class="title">MockObjectTestCase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String TALISKER = <span class="string">"Talisker"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFillingRemovesInventoryIfInStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//setup - data</span></span><br><span class="line">    <span class="comment">//启动阶段 - 数据部分</span></span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">50</span>);</span><br><span class="line">    Mock warehouseMock = <span class="keyword">new</span> Mock(Warehouse.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup - expectations</span></span><br><span class="line">    <span class="comment">// 启动阶段 - 期望部分</span></span><br><span class="line">    warehouseMock.expects(once()).method(<span class="string">"hasInventory"</span>)</span><br><span class="line">      .with(eq(TALISKER),eq(<span class="number">50</span>))</span><br><span class="line">      .will(returnValue(<span class="keyword">true</span>));</span><br><span class="line">    warehouseMock.expects(once()).method(<span class="string">"remove"</span>)</span><br><span class="line">      .with(eq(TALISKER), eq(<span class="number">50</span>))</span><br><span class="line">      .after(<span class="string">"hasInventory"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//exercise</span></span><br><span class="line">    <span class="comment">// 执行阶段</span></span><br><span class="line">    order.fill((Warehouse) warehouseMock.proxy());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//verify</span></span><br><span class="line">    <span class="comment">// 验证阶段</span></span><br><span class="line">    warehouseMock.verify();</span><br><span class="line">    assertTrue(order.isFilled());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFillingDoesNotRemoveIfNotEnoughInStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">51</span>);    </span><br><span class="line">    Mock warehouse = mock(Warehouse.class);</span><br><span class="line">      </span><br><span class="line">    warehouse.expects(once()).method(<span class="string">"hasInventory"</span>)</span><br><span class="line">      .withAnyArguments()</span><br><span class="line">      .will(returnValue(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">    order.fill((Warehouse) warehouse.proxy());</span><br><span class="line"></span><br><span class="line">    assertFalse(order.isFilled());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先着重看一下<code>testFillingRemovesInventoryIfInStock</code>方法，因为后面的例子会经常涉及该方法。</p>
<p>首先，启动阶段就跟之前的大相迥异。这一阶段包含两部分：数据和期望。数据部分是对关注对象的初始化，这跟传统的启动阶段非常类似。不同之处在于对象的创建方式。SUT还是订单对象，但是协作者就不再是仓库对象，而是一个mock的仓库对象。从技术上来讲，该mock的仓库对象是<code>Mock</code>类的一个实例。</p>
<p>启动阶段的第二部分是创建对mock对象的期望。所谓期望就是在SUT被执行时mock对象的哪些方法应该被调用。</p>
<p>一旦所有的期望都写好，我们就可以执行SUT的方法了。执行后接着就是验证，验证包括两方面。一方面跟之前一样我们会对SUT进行断言，另一方面我们也根据之前的期望对mock对象进行验证检查。</p>
<p>这里关键的区别在于我们如何验证订单对象(order)在与仓库对象的交互时是否做了对的事情。在状态验证里，我们是通过对仓库对象的状态进行断言。而mock采用的是行为验证，也就是检查订单对象是否正确地调用仓库对象的方法。我们在启动阶段告诉mock对象我们期望的行为，然后在验证阶段让mock对象来验证自己的行为是否符合期望。只有订单对象是通过断言来验证，如果该方法没有改变订单的状态，就根本不会有断言被触发。</p>
<p>第二个测试跟之前的有些不同。首先是创建mock对象的方式不同，这里我调用mock方法而不是构造函数来创建mock对象。这是jMock类库中很方便也很常用的方法，它使我之后不用显示地调用verify方法。采用该方法创建的mock对象都会在测试方法结束时自动地进行验证。本来第一个测试也可以采用这种方式，但我想显示地给大家展示一下mock的验证过程，来阐述基于mock的测试是如何进行的。</p>
<p>第二个测试中的另一个不同是我将期望部分的约束条件放松到<code>withAnyArguments</code>。这是因为在第一个测试中已经测试过传给仓库的数量，所以第二个测试就没必要重复这一部分的测试。如果以后订单对象的逻辑要改动，那么就只有一个测试会失败，这样就没减少重写测试的工作量。事实上我都可以完全不写<code>withAnyArguments</code>，因为这就是默认的。</p>
<h3 id="EasyMock的使用_(Using_EasyMock)">EasyMock的使用 (Using EasyMock)</h3><p>采用mock对象的类库还有很多，其中EasyMock是我遇到比较多的。EasyMock有Java和.NET两个版本。EasyMock同样支持行为的验证，但它的风格跟jMock却有点不同，这点很值得深入探讨。下面的测试还是我们熟悉的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEasyTester</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String TALISKER = <span class="string">"Talisker"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> MockControl warehouseControl;</span><br><span class="line">  <span class="keyword">private</span> Warehouse warehouseMock;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    warehouseControl = MockControl.createControl(Warehouse.class);</span><br><span class="line">    warehouseMock = (Warehouse) warehouseControl.getMock();    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFillingRemovesInventoryIfInStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//setup - data</span></span><br><span class="line">    <span class="comment">//启动阶段 - 数据部分</span></span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setup - expectations</span></span><br><span class="line">    <span class="comment">// 启动阶段 - 期望部分</span></span><br><span class="line">    warehouseMock.hasInventory(TALISKER, <span class="number">50</span>);</span><br><span class="line">    warehouseControl.setReturnValue(<span class="keyword">true</span>);</span><br><span class="line">    warehouseMock.remove(TALISKER, <span class="number">50</span>);</span><br><span class="line">    warehouseControl.replay();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//exercise</span></span><br><span class="line">    <span class="comment">// 执行阶段</span></span><br><span class="line">    order.fill(warehouseMock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//verify</span></span><br><span class="line">    <span class="comment">// 验证阶段</span></span><br><span class="line">    warehouseControl.verify();</span><br><span class="line">    assertTrue(order.isFilled());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFillingDoesNotRemoveIfNotEnoughInStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">51</span>);    </span><br><span class="line"></span><br><span class="line">    warehouseMock.hasInventory(TALISKER, <span class="number">51</span>);</span><br><span class="line">    warehouseControl.setReturnValue(<span class="keyword">false</span>);</span><br><span class="line">    warehouseControl.replay();</span><br><span class="line"></span><br><span class="line">    order.fill((Warehouse) warehouseMock);</span><br><span class="line"></span><br><span class="line">    assertFalse(order.isFilled());</span><br><span class="line">    warehouseControl.verify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EasyMock使用<code>记录/重现</code>这一模式来设置期望。对于每一个要mock的对象都创建一个控制对象和mock对象。mock对象用于满足辅助对象的接口，而控制对象而用于提供更多的特性。 我们通过调用<code>mock对象</code>的方法，并将期望的参数传给该方法，以此来描述一个期望。同样地，我们可以通过调用<code>控制对象</code>的方法来获得一个返回值。一旦所有的期望都设置完毕，我们就可以调用<code>控制对象</code>的replay方法，因为此时<code>mock对象</code>已经完成记录(recording)，随时可以响应<code>首要对象</code>的调用。上述步骤完成后我们就可以调用<code>控制对象</code>的verify方法。</p>
<p>第一眼看到<code>记录/重现</code>这种模式时，貌似大家都会感到很困扰，但很快就又习惯了。相对于jMock使用的约束，这种模式有个好处，就是你可以直接调用<code>mock对象</code>的方法，而不是通过指定该方法名字的字符串。这就意味着你可以利用起IDE中的代码补全功能，同时任何对方法名字的重构都可以自动更新测试代码。但缺点是无法做到更为宽松的约束。</p>
<p>jMock开发者正在开发新的版本，用其他技术来支持直接调用mock对象的方法。</p>
<h2 id="Mock和stub的区别(The_Difference_Between_Mocks_and_Stubs)">Mock和stub的区别(The Difference Between Mocks and Stubs)</h2><p>当mock对象第一次出现时，大家很容易将它跟常见的stub概念混淆起来。渐渐地，大家似乎对这两者的区别也有了更深入的理解(希望本文的旧版本在这过程能有所帮助)。然而，想要更加透彻地理解mock对象的使用，那么理解mock对象和其他形式的<code>测试替身</code>就尤为重要。(没有听过”替身”这个术语?没关系!接下来的几个段落会帮你弄明白的。)</p>
<p>按照上述方式进行测试时，你一次只关注软件的一个元素(这就是单元测试的基本概念)。但问题在于，为了让一个单元工作，你往往需要其他的单元，也就是我们的例子中的仓库对象。</p>
<p>上述的两种类型的测试中，第一种使用的是一个真实的仓库对象，而第二种使用的是一个mock的仓库(显然这并不是真实的仓库对象)。在这个测试中，使用mock对象仅仅是不用真实的仓库对象的一种方式，实际中还有很多其他形式的不使用真实对象技术来进行测试。</p>
<p>探讨这个话题时涉及很多诸如stub、mock、fake、dummy等词汇，很快就会使人迷失掉。这篇文章里我打算使用Gerard Meszaros的书中使用的术语。虽然这些术语并非所有人都这么用，但我觉得这些词汇真的很不错。还有就是因为在自己的文章里我有权利选择使用什么样的词汇。</p>
<hr>
<p><strong> dennis-xlc翻译部分完 <a href="http://blog.xulvcai.asia/2015/08/06/mocks-are-not-stubs-translation" target="_blank" rel="external">http://blog.xulvcai.asia/2015/08/06/mocks-are-not-stubs-translation</a> </strong></p>
<h2 id="笔者翻译部分"><strong> 笔者翻译部分</strong></h2><p>为完成测试任务，我们会用假的辅助对象来代替真实的对象，Meszaros 使用 Test Doubles 这个词来表示这些假冒的对象。这个名字来源于电影中的替身演员的概念。(使用这个名字的一个目的是为了避免与已存在的一些词产生歧义。）Maszaros 定义了四种典型的 Test Double：</p>
<ul>
<li><strong>Dummy</strong> 对象被传来传去，但从来不会被使用，它们常被用来填充参数列表。</li>
<li><strong>Fake</strong> 对象是一种可工作的实现，但一般会用比较简单快捷的方式来实现，不适用于产品环境（比如在测试中用内存数据库代替可持久化的数据库）。</li>
<li><strong>Stub</strong> 对象在测试中被调用时，会返回固定的结果，通常不会返回任何真实对象的内部逻辑。Stub可能还会记录关于如何调用的一些信息，例如 email gateway stub 会记录它「发出」的邮件内容，或者发出了多少封邮件。</li>
<li><strong>Mocks</strong> 是我们在这里提到的：mock 对象预先定义一些期望发生的行为，相当于形成了一套规范，当测试对象被调用是，来检查 mock 对象的行为是不是与规范一致。</li>
</ul>
<p>在各种的 Test Double 中，只有 Mocks 是对行为进行验证。其它的 Test Double 一般是对状态进行验证。Mocks 在执行上实际跟其它的 Test Double 类似，都是为了让 SUT 相信，它正在与真实的协作者交互， 但 Mocks 在准备阶段和验证阶段与其它的 Test Double 不同。</p>
<p>再深入一点研究 Test Double， 我们需要对之前的例子加强一下。很多人只有在真实的对象很难构造的情况下才使用 Test Double。对于 Test Double 更加常用的场景是：如果我们订单填写错误，我们想要收到一封邮件。问题是在测试中，我们不想真的向我们的客户发一封邮件，因此取而代之，邮件系统会被模拟成我们可以完全控制的 Test Double 对象。</p>
<p>这里我们就可以看到 mocks 和 stubs 的区别了。如果我们想要给发邮件的行为写一个测试，我们可以写一个简单的 stub ，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span> <span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailServiceStub</span> <span class="keyword">implements</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;Message&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span> <span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    messages.add(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberSent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> messages.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以使用 stub 进行状态验证了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderStateTester</span>...</span><br><span class="line">  <span class="title">public</span> <span class="title">void</span> <span class="title">testOrderSendsMailIfUnfilled</span>() </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">51</span>);</span><br><span class="line">    MailServiceStub mailer = <span class="keyword">new</span> MailServiceStub();</span><br><span class="line">    order.setMailer(mailer);</span><br><span class="line">    order.fill(warehouse);</span><br><span class="line">    assertEquals(<span class="number">1</span>, mailer.numberSent());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当然这是一个很简单的测试 - 仅仅是一封邮件被发出去了，我们还没有测这封邮件是否被发到了正确的人，内容是否正确。下面我们会看到如何做。</p>
<p>如果使用 mocks， 这个测试会看起来很不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderInteractionTester</span>...</span><br><span class="line">  <span class="title">public</span> <span class="title">void</span> <span class="title">testOrderSendsMailIfUnfilled</span>() </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">51</span>);</span><br><span class="line">    Mock warehouse = mock(Warehouse.class);</span><br><span class="line">    Mock mailer = mock(MailService.class);</span><br><span class="line">    order.setMailer((MailService) mailer.proxy());</span><br><span class="line"></span><br><span class="line">    mailer.expects(once()).method(<span class="string">"send"</span>);</span><br><span class="line">    warehouse.expects(once()).method(<span class="string">"hasInventory"</span>)</span><br><span class="line">      .withAnyArguments()</span><br><span class="line">      .will(returnValue(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">    order.fill((Warehouse) warehouse.proxy());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两种情况下，我用 Test Double 来代替真实的 mail service。在这里有一点不同的是，stub 用来做状态验证，而 mocks 用来做行为验证。</p>
<p>为了在 stub 上做状态验证，我需要在 stub 上创建一些额外的方法，来辅助验证过程。如你所见，stub 实现了 MailService 但增加了额外的辅助测试的方法。</p>
<p>Mock 对象只能行为进行验证，而 stub 既可以验证行为，也可以验证状态。Meszaros 提到 stub 可以作为 Test Spy，来进行行为的验证。不同之处在于这个 double 具体如何运行并进行验证，我把这个问题留给你，你可以深入研究一下。</p>
<h2 id="（Classical_和_Mockist_方式的测试）Classical_and_Mockist_Testing">（Classical 和 Mockist 方式的测试）Classical and Mockist Testing</h2><p>现在我们进入第二部分：在 TDD 时采用 classical 方式来还是采用 mockist 的方式。一个很大的问题就是什么时候应该使用 mock（或者其它 double）。</p>
<p><strong>classical TDD</strong> 方式是：如果可能，尽量用真实对象测试；如果真实对象很难构造使用，那么可以使用 double。因此经典的 TDDer 在刚才的例子中会创建真实的仓库对象，而对 mail service 创建一个 double，这种 double 并不太重要。</p>
<p>然而 <strong>Mockist TDD</strong> 的践行者，总会 mock 掉任何有相关性的对象，在这个例子中，会 mock 仓库和 mail service 对象。</p>
<p>虽然不同的 mock 框架是以各种 mockist 测试思想为基础来设计的，但很多 classicists 发现，这些框架在创建 double 方面很有用。</p>
<p>Mockist 风格的一个重要分支是行为驱动开发（BDD）。BDD 最初是由我的同事 Dan North 发明的，原本的目的是帮助人们理解测试驱动开发是如何帮助开发人员辅助代码设计的。BDD 通过把测试名称改为具体行为的名字，让你思考一个对象到底需要做什么事情，从而理解 TDD 在辅助设计方面的作用。BDD 采用了 mockist 的方案，但它扩展了这个方案，不仅在命名方面，还在使用这个技术做集成分析方面，在这里我就不深入探讨了。BDD 与这篇文章唯一相关的点在于，BDD 是 TDD 使用 mockist 测试方式的一个变种。我会留下它的参考链接，你可以获取更多关于它的信息。</p>
<h2 id="不同方案之间的选择（Choosing_Between_the_Differences）">不同方案之间的选择（Choosing Between the Differences）</h2><p>这这篇文章里，我讲了2个不同点：状态/行为验证 和 classical/mockist TDD。需要牢记于心的争论点在于 - 什么时候需要在它们之间做出选择？我们先从状态/行为验证讲起。</p>
<p>第一个需要考虑的是上下文（context）。我们要考虑一下，我们是在处理一个简单的依赖关系，就像订单和仓库之间的关系一样；还是一个比较复杂的关系，例如订单和邮件服务。</p>
<p>如果这是一个比较简单的关系，那选择就简单了。如果我是一个 classic 风格的 TDDer，我不会使用 mock、stub 或者任何类型的 double。我会使用真实对象以及状态验证。如果我是一个 mockist 风格的 TDDer，我会用 mock 来做行为验证。完全不需要多想，直接选就好了。</p>
<p>如果是一个比较复杂的关系，对 mockist 来说，也不需要选择 - 我只要用 mocks 以及行为验证就可以了。如果我是个 classicists，那么我确实需要做个选择，但要用哪种方式也没什么大不了的。通常 classicists 会具体问题具体分析，针对每一种情况都会采取最简单的方式。</p>
<p>因此正如我们看到的，状态验证亦或是行为验证，大部分情况下都不难决定。真正的问题在于 classic TDD 和 mockist TDD 之间。因为在现实情况下，状态和行为验证各自所具备的特点确实会影响到最后的决策，这是我投入最多精力研究的地方。</p>
<p>但在我继续论述前，让我抛出一个边界情况。你确实会遇到，在一些情况下，很难使用状态验证，即使这些对象并不是复杂的依赖关系。cache 是一个比较典型的例子，cache 的关键点在于你无法从状态去区分是否 cache 被成功命中了 - 在这种情况下，即使对 classical TDDer 来说，行为验证可能也将是个明智的选择。我确定这两种方式都会有一些其它的例外情况。</p>
<p>当我们深入研究了 classic/mockist 这两种选择后，会发现很多因素都需要考虑，因此我把它们进行了粗略的分组。</p>
<h2 id="驱动型TDD（Driving_TDD）">驱动型TDD（Driving TDD）</h2><p>Mock 对象出自 XP 社区，XP的一个最重要的特征就是它强调测试驱动开发 - 在这里，系统通过迭代，由测试驱动更新。</p>
<p>因此，mockists 专门谈论了 mockist 测试对于设计的影响就恨正常了。他们特别推崇一种称作是「需要驱动的开发」方式。使用这种方式，在你开始开发用户故事前，你会首先从你要开发的系统的外围系统的测试开始写起，会把接口对象当做 SUT（System Under Test）。通过思考各个对象互相之间的期望，来探索 SUT 和它的依赖对象之间的关系，这样就有效的设计了 SUT 外围系统的接口。</p>
<p>一旦你第一个测试跑起来了，对 mocks 期待的返回结果为下一步的设计提供了指导规范，也可以作为下一步测试的起始点。你把每一个期待都转换为对依赖对象的测试，一次只选取一个 SUT，不断的重复这个过程。这种方式也被直白地称为「由外向内」。这种方式在分层系统中可以良好应用。刚开始，你通过 mock UI 的下层代码来写 UI层代码，然后你可以写更低层代码的测试，逐渐一步步、一层层的深入。这是一种非常结构化，而且容易控制的方案，很多人都觉得这种方式对于指导新人理解 OO（面向对象）和 TDD 是很有帮助的。</p>
<p>经典的 TDD 的方法并不相同，你会用 stub 而不是 mocks，实现一个类似的一步步走的方案。想要做到这点，当你想从一个依赖对象那里得到一些返回值的时候，你只需要 hard-code 测试所需要的返回值，来使 SUT 可以工作。如果你觉得没问题了，你可以在真正的实现中把 hard code 替换成正确的代码。</p>
<p>但是经典 TDD 也会用其它方式。一种常见的方式是「由中间向两边」。用这种方式，如果你要做一个特性（feature），你要确定需要哪些领域模型才能让这个特性可以工作。然后你选取这些领域模型，把需要的方法添加进去，UI 层就是架构在领域模型的上层。使用这种方法，你可能完全不需要 fake 任何东西。很多人都喜欢这种方式，因为它首要关注领域模型，这样可以避免在 UI 逻辑中掺杂领域的业务逻辑。</p>
<p>我还要强调一点，不管是 mockists 还是 classicist 都应该一次做一张故事卡片。从前有一个特别的思维方式，就是我们要一层一层的写应用程序，在某一层结束之前，就不开始新一层的编写。classicist 和 mockists 都是在敏捷的背景之下衍生出来的，倾向于采用细粒度的迭代方式，这样致使他们会一个特性一个特性的完成工作，而不是一层一层的。</p>
<h2 id="Fixture_初始化（Fixture_Setup）">Fixture 初始化（Fixture Setup）</h2><p>使用经典的 TDD 方法，你需要创建的不只是 SUT，SUT 测试所依赖的全部对象你也要创建。虽然在这个例子中只有2个对象，但真实的测试经常会涉及大量的从属对象。这些对象也伴随着测试的运行而生成，伴随着测试运行完成而消亡。</p>
<p>然而，对于 Mockist 测试来说，你只需要创建 SUT，对它直接依赖的对象，你只要 mock 就可以了。这可以避免一些创建复杂 fixtures（测试基础设施）的工作（至少理论上是这样的。我已经遇到过很多 mock 对象复杂的初始化过程，当然也可能因为我没有用对工具。）</p>
<p>在实践中，classic 风格的测试倾向于尽可能重用复杂的 fixtures。最简单的方式，你可以把 fixture 初始化的代码放到 xUnit 的初始化方法里。如果有更多的复杂的 fixture 需要被多个测试类来使用，那么在这种情况下，你需要创建一些专门的 fixture 生成器。我经常称这些为 Objects Mother，这个名字基于一个早期的 ThoughtWorks XP 项目的命名规范。在大型项目中，在 classic 测试中使用 mothers 是非常重要的，但是 mothers 的代码是需要额外维护的，任何对 mothers 的修改可能会对其它的测试造成巨大的连锁影响。在初始化 fixture 时可能还会有性能消耗 - 虽然我没听说过如果正确使用的话，这会是个严重的问题。大部分的 fixture 对象的创建是恨廉价的，一般我们不会去模拟(doubled)。</p>
<p>由于上面的这些原因，以至于这两种方式都会指责对方会带来更多的工作量。Mockists 说创建 fixture 会带来很大的工作量，但 classicist 说 fixture 是可以重用的，而你们需要为每个测试都创建 mocks。</p>
<h2 id="测试隔离（Test_Isolation）">测试隔离（Test Isolation）</h2><p>如果你用 mockist 测试的方法引入了一个 bug，一般只会导致包含这个 bug 的 SUT 的测试失败。然而，如果使用的是 classic 方案，依赖这个有 bug 对象的所有对象对应的测试都有可能失败，因此，一个被高度依赖的对象如果出问题了，那么整个体统大量的测试都会失败。</p>
<p>Mockist 测试者认为这是一个很大的问题，为了找出错误的根源并修复它，需要花费大量的调试时间。然而，classicists 并不认为这是问题的源头。通常通过看一下哪个测试失败了，罪魁祸首还是相对容易定位的，开发可以辨识出哪些其它的错误是由根上的错误引发的。而且，如果你有规律地进行测试（你也应该这样做），那么你就可以知道问题是由上次你修改的什么引发的，因此找出错误并不那么难。</p>
<p>这里一个值得关注的点是测试的粒度。因为经典的测试会运用多个真实对象，你经常会发现某个测试会测一堆对象，而不是一个对象。如果这个测试会跨越到很多对象，那么就更难找到一个 bug 的真实源头了，这是由于测试粒度太粗导致的。</p>
<p>很可能 mockist 测试不太会被这个问题所困扰，因为惯例是 mock 掉所有主要对象以外的全部对象，对这些对象进行更细粒度的测试，这样会很清晰。也就是说，使用过于粗粒度的测试而导致的失败并不是由于 classic 测试技术导致的，避免这个问题的简单的做法，就是确保你为每个类都分离出了细粒度的测试。有的时候，对一堆对象的测试也是合理的，那它们也应该被限制到一个合适的数量 - 不要超过半打（6个）。另外，如果你发现由于测试粒度过于粗而导致了调试的问题，那么你应该使用测试驱动的方式来 debug，在 debug 过程中创建更多细粒度的测试。</p>
<p>本质上说，经典的 xunit 测试并不仅仅是视单元测试，也包括迷你的集成测试。因此，很多人认同这样一个事实：如果对一个对象的的测试漏掉了，那么客户端可能会捕获到一些错误，特别是类与一些比较深的区域交互时。而Mockist 测试带来了质量的损失。另外，在mockist 测试中你可能模拟了错误的期望值，虽然单元测试绿了，但掩盖了内在的错误，这也会带来风险。</p>
<p>我还要强调一点，无论你用的是哪种测试类型，你都必须结合粗粒度的可以贯穿整个系统的验收测试。我经常碰到因为项目太迟使用验收测试而后悔不已。</p>
<h2 id="与实现耦合的测试（Coupling_Tests_to_Implementations）">与实现耦合的测试（Coupling Tests to Implementations）</h2><p>当你写 mockist 测试的时候，你会测 SUT 的边界调用来保证它跟它的依赖对象是否协作良好。经典测试只会关心最终状态 - 而不是状态如何变迁。Mockist 测试与方法的实现耦合更严重。改变对协作者的真实调用会导致 mockist 测试挂掉。</p>
<p>这种耦合导致了两个潜在问题，最重要的一个是对测试驱动开发的影响。使用 Mockist测试，写测试时你会想想如何实现 - mockist 测试者确实会把这视为一种优势。然而，Classicists 认为仅仅是考虑外部接口对内部的影响比较重要，具体实现可以留到你写完测试之后再考虑。</p>
<p>对实现的耦合也会妨碍到重构，如果实现改变了，与比经典测试的方式相比，这种方式更可能破坏测试，</p>
<p>由于 mock 工具集的本质，这可能会更糟。通常，mock 工具会指定非常特定的方法调用和参数匹配，即使它们跟这些特定的测试不相关。jMock 工具的一个目标就是让期望判定规范更加灵活，允许期望在它不关心的领域更加松散，作为代价使用 string 可能会让重构更麻烦。</p>
<h2 id="设计风格（Design_Style）">设计风格（Design Style）</h2><p>对我来说，这些测试观念最迷人的一点是它们如何影响设计决策。由于我曾经跟这两种类型的测试者都谈过，我已经认识到了一些这种测试所侧重的不同点，但我还是觉得我仅仅是粗知一二。</p>
<p>在解决分层方面，我已经提过，这两种测试方式的不同点。Mockist 测试提供了一种由外而内的方案，而有些开发更倾向于从领域模型开始逐步向外开发的方式，他们则更喜欢经典的测试方式。</p>
<p>在更低的层次上我注意到 mockist 测试者 ，不喜欢有返回值的方法，更喜欢作用在收集对象上的方法。举个例子，比如你想要从一组对象中收集信息来创建一个字符串报告。常用的完成这件事的方法是写一个reporting方法，返回一个string，传入一些对象，在一个临时的变量里组装这个结果字符串。Mockist 测试者会更想要传一个string buffer进这个传入的对象中，然后让它们把不同的字符串加到这个buffer中 - 就是用这个string buffer来收集参数。</p>
<p>Mockist 测试者会更多的谈到避免「列车残骸」（train wrecks）- 形如 getThis().getThat().getTheOther() 这样的链式方法调用。避免链式调用也被称为符合迪米特法则。虽然方法链是一种坏味道，但它的反面 - 用一大堆中间对象做方法转发也是一种坏味道。（我总是感觉迪米特法则如果被称为迪米特建议会更令人舒服一点。）</p>
<p>在面向对象设计中，人们最难理解的一件事就是<a href="http://martinfowler.com/bliki/TellDontAsk.html" target="_blank" rel="external">『不要问，讲出来』原则</a>，这会鼓励你去让一个对象去做一些事情，而不是把对象的数据扯出来，在客户端代码中来做。Mockist 认为使用 mockist 测试可以帮助提高这一点，并防止 getter 方法乱飞。Classicists 则争辩说，有大量其它的方法可以做到这些。</p>
<p>基于状态验证的方法的一个的已知问题是，它会导致为了进行验证，会创建一些查询方法，仅仅为了测试。把一个测试方法加到对象的 API 中是绝不会令人舒服的一件事情，使用行为验证可以避免这个问题。它的反方观点认为，在实际中这种修正的影响往往比较小。</p>
<p>Mockists 风格的接口和 assert 更加鼓励使用角色接口，因为每个依赖对象是单独 mock 的，因此最好转成一个角色接口。因此在我上的例子里，使用了 string buffer 来生成一份报告，mockist 会更想要去发明一个在领域中有意义的专门的角色，不过还是用 string buffer 来实现的。</p>
<p>需要记住的很重要的一点是，设计方式上的这种不同对于大部分的 mockists 来说是一个很重要的驱动力。TDD 的初衷是自动的获取健壮的回归测试，来支持设计的演进。沿着这条路，它的实践者发现测试对设计过程产生了巨大的影响。Mockists 对什么样的设计是好的设计有非常强烈的见解，并且开发了 mock 的类库来帮助人们使用这种设计方式来开发软件。</p>
<h2 id="我应该成为_classicist_还是_mockist_？(So_should_I_be_a_classicist_or_a_mockist?)">我应该成为 classicist 还是 mockist ？(So should I be a classicist or a mockist?)</h2><p>我发现我没有自信回答这个困难的问题。个人来说，我一直是一个不潮流的的 classic TDDer，至今为止我没看到任何需要改变的原因。我没有看到 mockist TDD 带来了任何非常明显的好处，反而有点担心这种耦合了实现的测试所带来的后果。</p>
<p>当我观察了一个 mockist 程序员的工作后，有一点击败了我。我特别喜欢当写测试的时候，你会集中注意力在行为产生的结果上，而不是它如何实现的。为了写期望的值，一个 mockist 需要不断思考 SUT 应该如何实现，这种感觉我非常不爽。</p>
<p>我还没有在真实的项目上试过 mockist TDD，这种不利条件也让我有点痛苦。因为我通过测试驱动开发的方法学到了测试驱动开发，如果你没有认真试过的话，一般很难去判断一门技术的好坏。我认识很多好的开发是坚定的 mockist，因此虽然我是一个坚定的 classisist，我仍然会尽可能客观公平的列出这两种观点，让你自己决定要使用哪种方式。</p>
<p>因此，如果 mockist 测试听起来对你有吸引力的话，我建议不妨一试。如果你在 mockist TDD 想要改善的领域遇到一些问题的话，就特别值得试一试。我知道两个主要的领域，一个是如果测试废了，你花了大量的时间调试，因为测试没有清晰的告诉你哪里出问题了。（你也可以通过针对细粒度的对象组使用经典TDD的方法来改善这个问题。）第二个领域是如果你的对象没有包含足够的行为，mockist 测试会鼓励开发团队创建更多行为丰富的对象。</p>
<h2 id="写在最后（Final_Thoughts）">写在最后（Final Thoughts）</h2><p>单元测试的一个有趣之处在于，随着 xunit 框架和测试驱动开发的成熟，越来越多的人投入到了使用 mock 对象的方式中。在大量的实践中，人们学到了 mock 对象框架，而没有充分理解 mockist/classical 实质上的不同点。无论你倾向于哪一种方式，理解它们在观点上的不同都是很有用的。然而你并不一定要成为一个 mockist 来玩转 mock 框架，而是去理解测试如何指导软件设计决策的思想反而是大有裨益的。</p>
<p>这篇文章的目的曾经，以及现在都是，指出这两种测试方式的不同，来表明他们自身的妥协（trade-off）的地方。对于 mockist 的思考，相比我研究的这些，还有更多的内容，特别是它对设计方式的影响。我希望在未来几年，我们可以看到更多使用这种方式写的测试代码，那会加深你理解在写代码前先写测试的这种迷人的方式。</p>
<h2 id="深入阅读（Further_Reading）">深入阅读（Further Reading）</h2><p>想要透彻理解 xunit 测试实践，可以看一下 Gerard Meszaros 的新书(免责声明：这本在我的系列丛书中)。他也在维护一个<a href="http://xunitpatterns.com/" target="_blank" rel="external">网站</a>，包含这本书中的各种模式。</p>
<p>想要了解更多TDD的东西，可以先看 <a href="http://www.amazon.com/gp/product/0321146530%20?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321146530" target="_blank" rel="external">Kent’s book</a>。</p>
<p>想要了解 mockist 风格的测试，最好的全面的资源是 <a href="http://www.amazon.com/gp/product/0321503627?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627" target="_blank" rel="external">Freeman &amp; Pryce</a>。作者在维护 <a href="http://www.mockobjects.com/" target="_blank" rel="external">mockobjects.com</a>。特别是读一下这篇牛逼的论文 <a href="http://www.mockobjects.com/files/mockrolesnotobjects.pdf" target="_blank" rel="external">OOPSLA paper</a>。想要了解更多 TDD 的一个非常 mockist 方式的分支 - 行为驱动开发的内容，可以从 Dan North 的 <a href="http://dannorth.net/introducing-bdd/" target="_blank" rel="external">introduction</a> 开始看。</p>
<p>你还可以看下关于这些技术的工具网站 <a href="http://www.jmock.org/" target="_blank" rel="external">jMock</a>，<a href="http://www.nmock.org/" target="_blank" rel="external">nMock</a>，<a href="http://www.easymock.org/" target="_blank" rel="external">EasyMock</a> 以及 <a href="http://sourceforge.net/projects/easymocknet/" target="_blank" rel="external">.NET EasyMock</a>。（还有很多其它的工具没有在这里列出，不要以为这个列表是完成的。）</p>
<p>对于XP2000，可以看看<a href="http://www.mockobjects.com/files/endotesting.pdf" target="_blank" rel="external">original mock objects paper</a>，虽然已经相当过时了。</p>
<h2 id="重大修正（Significant_Revisions）">重大修正（Significant Revisions）</h2><p><em>02 January 2007</em>: Split the original distinction of state-based versus interaction-based testing into two: state versus behavior verification and classic versus mockist TDD. I also made various vocabulary changes to bring it into line with Gerard Meszaros’s book of xunit patterns.</p>
<p><em>08 July 2004</em>: First published</p>
<hr>
<p><strong> 笔者翻译部分完 </strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<div style="text-align:center" markdown="1"><br><img src="/assets/img/mocks-and-stubs.png" alt="mock&amp;stub"><br></div>

<p>最近在项目上做了一些跟测试相关的工作，这才发现以前的一些理论并不扎实，在跟别人吹牛的时候也容易被人问住，就找了一些旧文好好研究一下，看完后顿觉恍然大悟。</p>
<p>为了让对测试有兴趣但英语不佳的同学能够快速理解这些测试方法，觉得应该好好翻译一下。在网上搜了一下译文，发现有哥们 dennis-xlc 已经翻译了部分，我接着他的部分继续翻完，希望能给对测试有兴趣的同学一些启示。</p>]]>
    
    </summary>
    
      <category term="test" scheme="http://blankpapers.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[测试金字塔]]></title>
    <link href="http://blankpapers.com/2015/09/10/test-pyramid/"/>
    <id>http://blankpapers.com/2015/09/10/test-pyramid/</id>
    <published>2015-09-10T15:01:00.000Z</published>
    <updated>2015-09-11T05:59:25.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/assets/img/pyramid.png" alt="测试金字塔">  </p>
<p>原文: <a href="http://martinfowler.com/bliki/TestPyramid.html" target="_blank" rel="external">TestPyramid</a></p>
<p>译文: <a href="http://zyzhang.github.io/blog/2013/04/28/test-pyramid/" target="_blank" rel="external">测试金字塔</a></p>
<a id="more"></a>
<p>补充引用点的译文</p>
<h3 id="皮下测试（SubcutaneousTest）">皮下测试（SubcutaneousTest）</h3><p>我所说的皮下测试指的是对应用程序UI下层的测试。当你对应用做功能测试的时候，这特别有用。当你想要测试端到端的行为，但很难通过UI测试来测<a href="#yizhu1"><sup>译注1</sup></a>。</p>
<p>皮下测试可以解决有些逻辑很难在UI层进行测试的问题，而且比UI测试要快的多。但有个很大的问题是，除非你把所有的有用的业务逻辑都从UI层分离出来，否则有些重要的行为通过皮下测试会覆盖不到<a href="#yizhu2"><sup>译注2</sup></a>。</p>
<hr>
<ul>
<li>译注1: 比如一些权限相关的测试。比如一个系统有管理员和普通用户两种权限，如果你是普通用户，那么在前端你是无法看到或者操作管理员才有的功能的，即使你想要去使用这些功能（调用相应的接口），前端也会有相应的逻辑去屏蔽，给你返回形如”Not Authorized”这样的出错信息，但问题是，你是无法越过前端验证逻辑，直接请求后端接口这样的hack行为的，这时候就需要一些这样的”皮下测试“（我们常称为集成测试）来保证。<a id="yizhu1"></a></li>
<li>译注2: 老马就是说千万不要把业务逻辑混到UI里面啊！<a id="yizhu2"></a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/assets/img/pyramid.png" alt="测试金字塔">  </p>
<p>原文: <a href="http://martinfowler.com/bliki/TestPyramid.html">TestPyramid</a></p>
<p>译文: <a href="http://zyzhang.github.io/blog/2013/04/28/test-pyramid/">测试金字塔</a></p>]]>
    
    </summary>
    
      <category term="test" scheme="http://blankpapers.com/tags/test/"/>
    
  </entry>
  
</feed>
